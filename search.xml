<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[httpclient 4.5.2 学习随笔（1）]]></title>
      <url>%2F2016%2F12%2F19%2Fhttpclient-4-5-2-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[疑惑的地方刚开始接触httpclient的同学可能会比较疑惑，因为你发现创建httpclient的方式有两种： HttpClient client = new HttpClient(); CloseableHttpClient httpclient = HttpClients.createDefault(); 到底该使用那种方式来创建httpclient，或者使用httpclient 又该导入哪些包。标号1中，是commons-httpclient 版本的创建方式，标号2是 httpclient的版本。这两个版本都可以处理http请求。我查阅了一下apach的官网看到了这样的一句话： The Commons HttpClient project is now end of life, and is no longer being developed. It has been replaced by the Apache HttpComponents project in its HttpClient and HttpCore modules, which offer better performance and more flexibility.大意是commons-httpclient项目不再提供更新和开发。看着这句话我们应该明白了，以后HttpClient client = new HttpClient() 这种创建httpclient 的方式，也应该会被我们弃用掉。新建的项目还是使用httpclient 吧。 之所以写这篇文档，也算是给自己做一个记录吧，httpclient4.5的版本变化还是比较大的，网络上的很多文档都是基于4.4写的，有点过时了。在学习官方文档，教程，源码的基础上，给自己留下一个学习的小脚印。 序言 HTTP也许是当今互联网上使用的最重要的协议了，尽管java.net包提供了访问HTTP资源的基本功能，但是因为它的不够灵活，使得Httpclient的应用更加广泛。HttpClient 不是一个浏览器，它是一个客户端的HTTP通信实现库，httpclient的目标是发送和接收报文。 小Demo提供一个小demo ,看看这个httpclient到底该怎么用。 pom.xml文件中导入jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt; demo 程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import org.apache.http.Consts;import org.apache.http.HttpStatus;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;/** * describe * * @Author: soul * @Date: 2016/12/5 * @since: JDK 1.8 * @Version: v1.0 */public class Demo &#123; public static void main(String[] args) throws IOException, URISyntaxException &#123; example(); &#125; public static void example() throws URISyntaxException, IOException &#123; //创建httpclient实例，采用默认的参数配置 CloseableHttpClient httpClient = HttpClients.createDefault(); //通过URIBuilder类创建URI URI uri = new URIBuilder().setScheme(&quot;http&quot;) .setHost(&quot;www.baidu.com&quot;) .build(); HttpGet get = new HttpGet(uri) ; //使用Get方法提交 //请求的参数配置，分别设置连接池获取连接的超时时间，连接上服务器的时间，服务器返回数据的时间 RequestConfig config = RequestConfig.custom() .setConnectionRequestTimeout(3000) .setConnectTimeout(3000) .setSocketTimeout(3000) .build(); //配置信息添加到Get请求中 get.setConfig(config); //通过httpclient的execute提交 请求 ，并用CloseableHttpResponse接受返回信息 CloseableHttpResponse response = httpClient.execute(get); //服务器返回的状态 int statusCode = response.getStatusLine().getStatusCode() ; //判断返回的状态码是否是200 ，200 代表服务器响应成功，并成功返回信息 if(statusCode == HttpStatus.SC_OK)&#123; //EntityUtils 获取返回的信息。官方不建议使用使用此类来处理信息 System.out.println(&quot;Demo.example --------&gt;&quot; + EntityUtils.toString(response.getEntity() , Consts.UTF_8)); &#125;else &#123; System.out.println(&quot;Demo.example --------&gt;&quot; + &quot;获取信息失败&quot;); &#125; &#125;&#125; 上面的程序基本上能满足一些简单的数据请求。总结下httpclient的使用步骤： 创建httpclient实例 创建httpmethod 方法实例 ，最常用的是HttpGet,HttpPost 类 httpclient 通过execute方法提交Get 或者Post 请求 使用CloseableHttpResponse 来接受服务器返回的状态信息和实体信息 关闭连接 HTTP 请求 所有的HTTP请求都有一个请求的起始行，由方法名，uri和HTTP协议版本组成 。HttpClient很好的支持了HTTP/1.1规范中所有的HTTP方法：GET，HEAD,POST ,PUT ,DELETE ,TRACE 和 OPTIONS。每个方法都对应一个类：HttpGet,HttpHead,HttpPost,HttpPut,HttpDelete,HttpTrace和HttpOptions。uri-&gt;统一资源定位符，包含了协议名称（http,https,ftp）,主机名（www.xxx.com,www.xx.cn）,可选端口（如果为80端口，可以省略），资源路径（/search）,可选参数，可选片段等。url如下： http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq= HttpClient提供了URIBuilder工具类来简化创建。修改request URI .1234567891011URI uri = new URIBuilder().setScheme(&quot;http&quot;) .setHost(&quot;www.google.com&quot;) .setPath(&quot;/search&quot;) .setParameter(&quot;q&quot; ,&quot;httpclient&quot;) .setParamter(&quot;btnG&quot; ,&quot;google+Serach&quot;) .build() ;HttpGet get = new HttpGet(uri) ;//除了使用URIBuilder工具类来创建连接，也可以直接采用字符串来定义uriString url = http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq ；HttpGet get = new HttpGet(url); //效果也是一样的 Http 响应 HTTP响应是服务器接收并解析请求信息后返回给客户端的信息，它的起始行包含了一个协议版本，一个状态和描述状态的短语。Http/1.1 , 200 ,Ok HTTP 实体 HttpClient 分为三种实体： 流式实体：内容来源于一个流，或者在运行中产生。流式实体不可重复。 自我包含：内存中的内容，通过独立的链接/其他的实体获得的内容。自我包含实体可重复 包装实体：从另外一个实体中获得内容。 服务器返回的信息封装在了entity中，客户端通过调用response.getEntity 可以拿到该实体内容。通过HttpEntity#getContent()方法，可以将数据转换成一个InputStream流。或者提供一个输出流给HttpEntity#writeTo(Outputstream)方法，它将会返回写入给定流的所有内容。官方其实是不建议使用EntityUtils类的，除非响应的实体来自于信任的Http服务器，并且知道它的长度。 释放低级别的资源 为了确保正确的释放资源，你必须关掉与实体相关的内容流，还必须关掉响应流。 inputStrea.close() response.close() 参考： http://blog.csdn.net/u011179993/article/details/47123727]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Http 协议简析]]></title>
      <url>%2F2016%2F12%2F18%2FHttp-%E5%8D%8F%E8%AE%AE%E7%AE%80%E6%9E%90%2F</url>
      <content type="text"><![CDATA[引言HTTP是一个属于应用层的面向兑现的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它与1990年提出。目前使用的版本是HTTP/1.1版本。 HTTP协议 协议是指两台计算机之间进行通信必须共同遵守的规定或者规则。超文本传输协议是一种通信协议，它允许将超文本标记语言文档从web服务器传送到客户端的浏览器。特点 支持客户端/服务器模式（C/S）。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是每次连接只能处理一个请求。服务器处理完客户的请求后，并受到客户的应答，即断开连接。 无状态：HTTP协议是无状态的。无状态是指协议对于事务处理没有记忆能力。本次的请求和上一次请求并没有关系，对于服务器来说，并不知道两次请求来自同一个客户端。 WEB浏览器、服务器、代理服务器 当我们输入网址之后，就能看到网页，原理是怎样的呢，简单的解析一下： 客户端与服务端通过http协议建立连接。 连接建立之后，发送request请求，请求格式为：URL，协议的版本号，客户机信息等内容。 服务器受到请求之后，作为响应，返回客户端的请求内容。 客户端浏览器收到服务的信息后，解析内容，显示在浏览器界面上。 请求过程如下面图片所示： 我们的请求又可能不是通过客户端直接和服务端连接的，中间可能会加一个代理的服务器，客户端先和代理服务器连接，之后在和目标服务器连接，这样可以隐藏客户端的ip,这种方式在爬虫中比较常用，它可以提高访问的速度，突破封锁的限制，隐藏客户端的信息。请求过程如下图所示： HTTP代理服务器简单说，http代理服务器就是网络信息的中转站，代理服务器具有缓存的功能，有很大的存储空间。对于客户端来说，代理服务器相当于服务端，对于都服务端来说，代理服务器就是要一个客户端。 HTTP URL组成解析 URL描述的是网络上的资源，任何信息都可以通过URL找到它。http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 格式如下： http://www.test.com/search/yuluo?id=1234&amp;name=zhangsan scheme 指定底层使用的协议（http ,https ,ftp） host 服务器的ip地址，域名 ,上例中的 www.test.con port 端口号 一般默认是80 可以不写 ，若是其他端口，如8080 必须要书写. path 访问的资源路径 /search/yuluo query-string 发送给http的数据 id=1234&amp;name=zhangsan HTTP消息结构 request-line 请求行:请求的种类，请求的路径，http协议版本 http header ：http 头部信息 body ： 发送给服务器的query信息 当时用Get方法的时候，body是空的 Get： Host: Accept : 浏览器可以接受的媒体类型 / 任意类型 Accept-Encoding： 申明自己接收的编码方法 Accept-Language： 申明自己接收的语言 Cache-Control：Response-Request遵循的缓存机制 Cookie： 将cookie的值发送给服务器 Referer: User-Agent：客户端使用的系统和浏览器的版本 Post 请求 Post： Host： Accept： Accept-Encoding： Accept-Language: Cache-Control: Cookie: Referer: User-Agent: body : Get和Post请求的区别 Get 一般用于获取/查询资源信息，请求参数携带在url中Post 一般用于更新资源信息 ，url中无参数信息 请求方法 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 常用状态码 200 OK : 表明响应成功，所请求的资源发给浏览器 302 found : 重定向，新的请求放在了Location中，浏览器从Location中提取连接欸，重新请求。 400 Bad Request : 客户端的请求，不能被服务器所理解 401 Unauthorized : 请求未经授权 403 Forbidden : 服务器收到请求，拒绝提供服务 404 Not Found : 找不到请求资源 500 Internal Server Error : 服务器错误 503 Server Unavailable 服务器当前不能处理请求 响应消息 客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误的编码、实体元信息以及必要的实体内容。包括： 状态行 消息报头 响应正文 响应报头 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头 LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。 ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。 HTTP无状态问题 通过Cookie 保存状态信息 。每次请求的时候携带cookie的信息，服务端就可以知道你来自同一个浏览器。 通过session 保存状态信息。session是一种服务器端的机制。 cookie和session的区别 cookie状态保存在客户端，session状态保存在服务器端 cookie是服务器端在客户端机上存储的一小段文本，并随每次请求一起发送到服务端 session是针对每一个用户，变量值保存在服务器中 从安全角度讲，session的安全性更好一些]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客主题配置、定制]]></title>
      <url>%2F2016%2F12%2F12%2F%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E3%80%81%E5%AE%9A%E5%88%B6%2F</url>
      <content type="text"><![CDATA[上一篇文章中，成功的完成了博客的搭建，不得不说，就我个人来言，官方默认的主题真实太丑，作为一个追求简约，喜欢简单布局的人，真的是一种精神折磨，太让人受不了了。经过比较最终选择了精于心，简于形的Next主题。站点和主题都有配置文件_config.yml ，为了便于区分，博客根目录的配置文件我们称为站点配置，主题的配置文件我们称为主题配置文件。 主题替换 下载主题 进人你博客的根目录，运行Git Bash Here 。输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 主题下载完成后，将文件夹改名为next 。 切换主题 打开博客根目录，找到_config.yml 。 找到 theme 字段，并将其值更改为 next。 theme 和 next 之间有空格!! 1theme: next 保存之后，我们的主题已经替换完成了，在本地验证一下，在运行之前，先运行hexo clean 清楚一下缓存，运行 hexo g 生成一下，最后运行hexo s 。在浏览器输入网址，http://localhost:4000, 验证一下效果。效果图如下：说明替换成功了。 主题设定 NexT 有三种Scheme,他们是： Muse - 默认 Mist - 紧凑版本 Pisces - 双栏Scheme,小家碧玉似的清新 设定方法是： 切换到 next 文件夹 ， 打开_config.yml配置文件 1234# Schemesscheme: Muse#scheme: Mist#scheme: Pisces 将注释去掉就可以切换scheme了。 设置语言 站点配置文件更改语言： language: zh-Hans , 改为中文。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建个人博客]]></title>
      <url>%2F2016%2F12%2F12%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言 很久之前就像要一个自己的博客，想在这个浩瀚的网络上，能有一个自己的小家，简单的写写文章，记录一下自己的心路历程。虽然有各种博客，但是风格都是官方定好的，完全没有自己发挥的空间。 虽然wordpress可以搭建个人博客，但是服务器空间域名等都需要钱来维护，而且wordpress使用起来也不是很爽。直到发现了githubpage和hexo。一颗躁动的心又要起航了。概述 github： 是一个面向开源及私有软件项目的托管平台，只支持git作为唯一的版本库格式进行托管，故名GitHub 。也是众多程序员聚集的地方,目前拥有超过 900 万的开发用户。 node.js： Node是一个服务端JavaScript解析器，他将改变服务器如何工作的概念。目标是帮助程序员构建可伸缩的应用程序，虽然说了这么多，我能说其实我也不会用吗 。。。 git: 一款免费的开源的分布式版本控制系统，用于敏捷高效的处理任何或小或大的项目 Hexo: 一款基于NODE.JS的快速、简单的博客框架，能够创建一个项目进行编辑后生成一套静态网页，比较适合个人博客的搭建。可以急速生成静态网页，支持MarkDown。 github pages : 300M免费空间，资料可以自己管理，免费使用，并且快速稳定。 软件下载地址传送门 node.js : https://nodejs.org/en/download/git : https://github.com/git-for-windows/git/releases/tag/v2.11.0.windows.1 环境安装 安装node.js， 我下载的是 .msi 的安装包， 软件会默认将安装路径添加到path中。 安装git，如果不会安装，请自行搜索教程 本机环境 windows 8.1 git版本： version 2.10.1.windows.1 nodejs版本： v6.9.2 实战开始 安装 配装 使用 Hexo Hexo需要的环境搭建好之后，我们开始安装hexo 。 安装Hexo 在电脑的任意位置，创建一个文件夹，文字随便命名看你喜欢了，鼠标右键，点击Git Bash Here ,输入命令即可安装 。 npm install -g hexo npm install hexo –save hexo init npm install npm install hexo-deployer-git –save //ERROR Deployer not found: git 安装这个插件 安装成功的目录： 本地查看运行效果： 运行命令： hexo generate 命令简写 hexo ghexo server 命令简写 hexo s 浏览器运行结果： 在浏览器输入 http://localhost:4000 , 即可看到本地的运行的效果。 淘宝源安装 npm install -g cnpm –registry=https://registry.npm.taobao.org之后的安装就是把npm install 换成 cnpm install 看到上面的图片，说明我们hexo本地的安装已经成功，接下来就是将我们的文件上传到github了，首先我们需要有一个github账号，直接去注册就好了，作为一个屌丝程序员，怎么可能没有github账号，之后就是设置ssh公钥，设置的方式： 登陆账号后，鼠标点击你的头像，点击-Your profile 点击左边的 ， Edit profile 左边，SSH and GPG keys 右边，New SSH key 随便输入 title , key 文本框中，输入公钥，点击Add SSH key 创建仓库 New repository ， 创建新仓库 Repository name ,这个是重点 ！！一点要填写为：你的账号名.github.io 。 完成仓库的创建 。 结果如下图： 部署到github 仓库创建成功以后，我们可以将本地的网页文件上传到github了，下面我们看一下具体的设置： 打开,你创建文件夹的根目录 ，找到 _config.yml文件 ，在最后面添加下面的代码： 1234deploy: type: git repository: 你的仓库地址 branch: master hexo 的配置已经完成。 接下来，我们使用hexo命令将文件上传到github仓库中。 123hexo clean # 清楚缓存hexo g # 生成静态网页至public目录hexo d # 发布到github 效果如下图说明发布成功 在浏览器输入 Your-Github-Name.github.io ,就可以查看你的博客了。 到这里，博客已经基本创建好了，后续会继续跟进博客主题的替换，博客样式的设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F12%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
