<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[httpclient 4.5.2 学习随笔（4）]]></title>
      <url>%2F2017%2F01%2F09%2Fhttpclient-4-5-2-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%EF%BC%884%EF%BC%89%2F</url>
      <content type="text"><![CDATA[代理认证是爬虫的利器，现在稍微有一点规模的网站，反爬虫程序多少都会有一个点，只要程序请求的速度稍微快了一点，本地ip 就会被干掉，httpclient 作为下载网页资源的中干力量，多数爬虫都是使用httpclient 来下载，本章我们就来看一下httpclient的代理机制。 HTTP 认证任何用户认证的过程，都需要一系列的凭证来确定用户的身份。最简单的用户凭证可以是用户名和密码这种形式。UsernamePasswordCredentials这个类可以用来表示这种情况，这种凭据包含明文的用户名和密码。这个类对于HTTP标准规范中定义的认证模式来说已经足够了。UsernamePasswordCredentials creds = new UsernamePasswordCredentials(&quot;username &quot; ,&quot;password&quot;) 使用上面的语句来设置用户名密码。 Authentication schemes 身份认证方案 AutoScheme接口表示一个抽象的面向挑战/响应的认证方案。一个认证方案要支持下面的功能： 客户端请求服务器受保护的资源，服务器会发送过来一个chanllenge(挑战），认证方案（Authentication scheme）需要解析、处理这个挑战 为processed challenge提供一些属性值：认证方案的类型，和此方案需要的一些参数，这种方案适用的范围 使用给定的授权信息生成授权字符串;生成http请求，用来响应服务器发送来过的授权challenge HttpClient的船舶有几个AuthScheme 实现： Basic： 在RFC 2617中该验证方案定义基本身份验证机制是不安全的，因为凭据以明文形式传输。尽管它不安全，如果与TLS / SSL加密结合使用基本身份验证方案是完全足够了。 Digest。 摘要式身份验证方案在RFC 2617摘要式身份验证方案定义比基本显著更安全，更可以为那些不想通过TLS / SSL加密全程运输安全的开销这些应用的理想选择。 凭证 provider 凭证providers旨在维护一套用户的凭证，当需要某种特定的凭证时，providers就应该能产生这种凭证。认证的具体内容包括主机名、端口号、realm name和认证方案名。当使用凭据provider的时候，我们可以很模糊的指定主机名、端口号、realm和认证方案，不用写的很精确。因为，凭据provider会根据我们指定的内容，筛选出一个最匹配的方案。只要我们自定义的凭据provider实现了CredentialsProvider这个接口，就可以在HttpClient中使用。默认的凭据provider叫做BasicCredentialsProvider，它使用java.util.HashMap对CredentialsProvider进行了简单的实现。 1234CredentialsProvider credsProvider = new BasicCredentialsProvider();credsProvider.setCredentials( new AuthScope(&quot;somehost&quot;, AuthScope.ANY_PORT), new UsernamePasswordCredentials(&quot;u1&quot;, &quot;p1&quot;)); HTTP认证和执行上下文 HttpClient依赖AuthState类去跟踪认证过程中的状态的详细信息。在Http请求过程中，HttpClient创建两个AuthState实例：一个用于目标服务器认证，一个用于代理服务器认证。如果服务器或者代理服务器需要用户的授权信息，AuthScope、AutoScheme和认证信息就会被填充到两个AuthScope实例中。通过对AutoState的检测，我们可以确定请求的授权类型，确定是否有匹配的AuthScheme，确定凭据provider根据指定的授权类型是否成功生成了用户的授权信息。 在Http请求执行过程中，HttpClient会向执行上下文中添加下面的授权对象： Lookup对象，表示使用的认证方案。这个对象的值可以在本地上下文中进行设置，来覆盖默认值。 CredentialsProvider对象，表示认证方案provider，这个对象的值可以在本地上下文中进行设置，来覆盖默认值。 AuthState对象，表示目标服务器的认证状态，这个对象的值可以在本地上下文中进行设置，来覆盖默认值。 AuthState对象，表示代理服务器的认证状态，这个对象的值可以在本地上下文中进行设置，来覆盖默认值。 AuthCache对象，表示认证数据的缓存，这个对象的值可以在本地上下文中进行设置，来覆盖默认值。 从版本4.1开始，HttpClient就会自动缓存验证通过的认证信息。但是为了使用这个缓存的认证信息，我们必须在同一个上下文中执行逻辑相关的请求。一旦超出该上下文的作用范围，缓存的认证信息就会失效。 抢先认证 HttpClient默认不支持抢先认证，因为一旦抢先认证被误用或者错用，会导致一系列的安全问题，比如会把用户的认证信息以明文的方式发送给未授权的第三方服务器。因此，需要用户自己根据自己应用的具体环境来评估抢先认证带来的好处和带来的风险。即使如此，HttpClient还是允许我们通过配置来启用抢先认证，方法是提前填充认证信息缓存到上下文中，这样，以这个上下文执行的方法，就会使用抢先认证。 123456789101112131415161718HttpHost targetHost = new HttpHost(&quot;localhost&quot;, 80, &quot;http&quot;);CredentialsProvider credsProvider = new BasicCredentialsProvider();credsProvider.setCredentials( //代理主机的ip和端口 new AuthScope(targetHost.getHostName(), targetHost.getPort()), //代理主机的用户名密码 new UsernamePasswordCredentials(&quot;username&quot;, &quot;password&quot;));// Create AuthCache instanceAuthCache authCache = new BasicAuthCache();// Generate BASIC scheme object and add it to the local auth cacheBasicScheme basicAuth = new BasicScheme(); authCache.put(targetHost, basicAuth); //将目标的验证方案放入缓存中// Add AuthCache to the execution contextHttpClientContext context = HttpClientContext.create();context.setCredentialsProvider(credsProvider); //上下文中添加认证凭证context.setAuthCache(authCache); //上下文中加入认证缓存 在爬虫应用中，当使用代理的时候，我是喜欢将代理加载路由中，HttpClient 能够直接建立连接到目标主机，或者通过路由，但这会涉及多个中间连接–也被称为“一跳” 。HttpRoutePlanner是一个接口，它代表计算到基于执行上下文到给定目标完整路由策略。 如果采用的是静态代理，也就是只有ip地址，和端口号的代理，上面的代码需要在改动一下，上面的内容为云代理，需要用户名和密码验证才能登陆代理服务器，有代理服务器做地址转发 123456//创建代理地址实例HttpHost proxy = new HttpHost(&quot;127.0.0.1&quot;, 8087); //创建路由 使用DefaultProxyRoutePlanner DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);//路由添加到httpclient 实例创建中 CloseableHttpClient httpClient =HttpClients.custom().setRoutePlanner(routePlanner).build(); 上面为静态代理，无用户名密码验证的代理使用方式 如果代理需要用户名和密码验证，则使用下面的方式： 123456789HttpRoutePlanner httpRoute = new HttpRoutePlanner() &#123; @Override public HttpRoute determineRoute(HttpHost target, HttpReques httpRequest, HttpContext httpContext) throws HttpException &#123; //可以在此处添加验证的信息 。。。 return new HttpRoute(target , httpHost); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[httpclient 4.5.2 学习随笔（3）]]></title>
      <url>%2F2017%2F01%2F09%2Fhttpclient-4-5-2-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%EF%BC%883%EF%BC%89%2F</url>
      <content type="text"><![CDATA[连接管理两个主机之间建立的过程是很复杂的，包括了两个终端之间许多数据包的交换，会消耗掉大量的时间。对于很小的HTTP报文传输，TCP/IP的握手环节也是必不可少的。如果已有的链接能够重复使用，来执行多个请求，将会加大程序的数据吞吐量。HttpClient完全地支持连接持久化。 连接路由 HttpClient能够直接建立连接到目标主机，或者通过路由，但这会涉及多个中间连接–也被称为“一跳”。HttpClient 区分连接路由plain,tunneled和laryed。连接到目标主机的隧道使用多个中间代理，被称为代理链。 直接连接到目标主机或仅仅有一个代理的是plain路由 通过一个代理或者代理链连到目标主机是tunneled路由，没有代理的路由不是tunneled路由 通过已有连接加上协议分层是 layered 连接管理器 HTTP连接是复杂的，有状态的，非县城安全的对象。 HTTP连接 一次仅只能有一个执行线程来使用，HttpClient 采用一个特殊实体来管理访问HTTP连接，这被称为HTTP连接管理器，ClientConnectionManager 接口就是代表。HTTP连接管理器的目的是作为工厂创建新的HTTP连接，管理持久连接的生命周期和同步访问持久连接。内部的HTTP连接管理器使用OperatedClientConnection实例，这个实例为真正的连接扮演了一个代理，来管理连接状态和控制I/O操作执行。如果一个管理的连接被释放或者被使用者明确地关闭，潜在的连接就会从它的代理分离，退回到管理中。 BasicHttpClientConnectionManager 是一个简单的连接管理器，它保持一次只有一个连接，尽管这个方法是线程安全的，它也应该一次使用一个县城。如果连接已经被分配，将会抛出java.lang.IllegalStateException异常，连接管理器应该在EJB容器中实现。 连接池管理器 Pool Connection Manager PoolingHttpClientConnectionManager 是一个管理客户端连接更复杂的实现。它为执行多线程的连接请求提供服务。对于每个基本的路由，连接都是池管理的。对于路由的请求，连接器在池中有可用的持久性连接，将被从池中取出连接服务，而不是创建一个新的连接。对每个基本路由，PoolingHttpClientConnectionManager保持着一个最大限制的连接数。使用HttpClient.close() 释放连接。 当使用PoolingClientConnectionManager 时可以使用多线程来同时执行多个请求。如果池中没有可用的连接，请求将会被阻塞，直到有可用的连接。如果在一定的时间内不能被响应，将会抛出ConnectionPoolTimeoutException异常。 Socket 工厂 HTTP 连接内部使用java.net.Socket 来传输数据，依靠ConnectionSocketFactory接口来创建、初始化和连接socket。PlainConnectionSocketFactory是创建、初始化普通socket的工厂。扩展ConnectionSocketFactory 的类还有LayeredConnectionSocketFactory、SSLConnectionSocketFactory （安全套接字创建工厂）。 代理配置 尽管HTTPClient 了解复杂的路由模式和路由链，但它指支持简单的重定向或者一跳代理连接。你也可以实现一个自定义的RoutePlanner,来实现一个完整控制HTTP路由计算的处理器。 Cookie Cookie 是HTTP代理和目标服务器可以交流保持会话的状态信息的令牌或小的数据包。创建方式：CookieStore cookieStore = new BasicCookieStore() ; 可以将cookie设置在上下文中，这样服务器就可以识辨多次请求来自同一个客户端。BasicCookieStore 使用java.util.TreeSet 的简单实现。 Lookup 实例代表了真实的cookie详细记录，这个属性的值设置在本地上下文中，优先于默认的 CookieSpec 实例代表了真实的cookie规范 CookieOrigins 实例代表了当前的源服务器的详情 CookieStore 实例代表了当前cookie store ,这个属性的值设置在本地上下文中而优先于默认 通过下面的代码设置cookie : 123CookieStore cookie = new BasicCookieStore() ;HttpClientContext httpClientContext = HttpClientContext.create();httpClientContext.setCookieStore(cookie); 没有什么使用写一遍代码解决不了的，一遍不行那就写两边，上面说了这么多，肯定蒙蔽了，好了我们直接上代码，我们看一下用上面的内容如何来组装程序，组装成要给一个可以多次请求的demo。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class HttpClientUtils &#123; private final HttpClientContext context = new HttpClientContext() ; //初始化上下文实例 private final HttpClientConnectionManager manager = builderPoolConnectionManager() ; //定义连接池管理变量 public HttpClientUtils()&#123; CookieStore cookieStore = new BasicCookieStore() ; context.setCookieStore(cookieStore); &#125; public HttpClientConnectionManager builderPoolConnectionManager()&#123; final SSLContext context = SSLContexts.createSystemDefault(); final HostnameVerifier verifier = new DefaultHostnameVerifier() ; //自定义注册器，既可以发送http请求，也可以发送https请求 final Registry&lt;ConnectionSocketFactory&gt; register = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create() .register(&quot;http&quot; , PlainConnectionSocketFactory.INSTANCE) .register(&quot;https&quot; , new SSLConnectionSocketFactory( context ,verifier)) .build() ; PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager(register); poolingHttpClientConnectionManager.setMaxTotal(200); //设置连接池的最大连接数 poolingHttpClientConnectionManager.setDefaultMaxPerRoute(poolingHttpClientConnectionManager.getMaxTotal()); //一个路由的最大连接数 return poolingHttpClientConnectionManager ; &#125; public HttpClient buildHttpClient()&#123; RequestConfig config = RequestConfig.custom() .setConnectionRequestTimeout(3000) //从池中获取请求的时间 .setConnectTimeout(2000) //连接到服务器的时间 .setSocketTimeout(5000).build(); //读取信息时间 //如果使用了代理，请打开注释// HttpHost proxy = new HttpHost(&quot;127.0.0.1&quot; , 2924) ;// HttpRoutePlanner httpRoutePlanner = new HttpRoutePlanner() &#123;// @Override// public HttpRoute determineRoute(HttpHost httpHost, HttpRequest httpRequest, HttpContext httpContext) throws HttpException &#123;// return new HttpRoute(httpHost ,proxy);// &#125;// &#125;; CloseableHttpClient build = HttpClients.custom() .setRetryHandler(DefaultHttpRequestRetryHandler.INSTANCE) .setDefaultRequestConfig(config) .setConnectionManagerShared(true) .setConnectionManager(manager)// .setRoutePlanner(httpRoutePlanner) 设置路由 .build(); return build ; &#125; public static void main(String[] args) throws IOException &#123; HttpClientUtils utils = new HttpClientUtils() ; HttpClient httpClient = utils.buildHttpClient(); HttpGet get = new HttpGet(&quot;http://www.qq.com&quot;); HttpResponse response = httpClient.execute(get, utils.context); System.out.println(EntityUtils.toString(response.getEntity() , Consts.UTF_8)); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[httpclient 4.5.2 学习随笔（2）]]></title>
      <url>%2F2016%2F12%2F29%2Fhttpclient-4-5-2-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[HTML表单许多应用需要模仿一个登陆HTML表单的过程，比如：为了登陆一个WEB应用或者提交输入的数据。Httpclient 早就为我们准备好了，提供了UrlEncodedFormEntity类来简化操作。我们来看一下核心的代码：1234List&lt;NameValuePair&gt; list = new ArrayList&lt;&gt;() ;list.add(new BasicNameValuePair(&quot;name&quot; ,&quot;zhangsan&quot;));list.add(new BasicNameValuePair(&quot;age&quot; ,&quot;18&quot;));UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(list ,Consts.UTF_8) ; post方法提交demo123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.apache.http.Consts;import org.apache.http.HttpStatus;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created by YuLuo on 2016/12/5. */public class PostDemo &#123; public static void main(String[] args) throws IOException &#123; demo(); &#125; public static void demo() throws IOException &#123; //创建httpclient 实例 CloseableHttpClient httpclient = HttpClients.createDefault(); //创建post方法实例 HttpPost post = new HttpPost(&quot;http://host/.com&quot;) ; //封装提交到服务器的参数信息 List&lt;NameValuePair&gt; list = new ArrayList&lt;&gt;() ; list.add(new BasicNameValuePair(&quot;name&quot; ,&quot;zhangsan&quot;)); list.add(new BasicNameValuePair(&quot;age&quot; ,&quot;18&quot;)); UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(list , Consts.UTF_8) ; //设置参数信息 post.setEntity(formEntity); //提交post方法 CloseableHttpResponse respone = httpclient.execute(post); int statcode = respone.getStatusLine().getStatusCode() ; if(statcode == HttpStatus.SC_OK)&#123; System.out.println(EntityUtils.toString(respone.getEntity())); &#125; &#125;&#125; 解析NameValuePair 通过查看源码，发现NameValuePair只有两个方法： getName() getValue() BasicNameValuePair作为NameValuePair的实现类，只有两个字段，Name和Value ，并且它还实现了Cloneable ，Serializable 两个接口。BasicNameValuePair 没有提供属性的setter方法。只能通过构造方法，为字段赋值。 内容分块 通过HTTP#setChunded()方法来通知HttpClient你要进行分块处理， 由Httpclient根据被传输的报文属性选择最合适的传输编码方式。当使用一些不支持分块的版本（http /1.0）时，这个值会被忽略掉。 Http执行上下文 context 最初，HTTP是被设计成无状态的，面向请求-响应协议。然而，我们在使用的过程中，经常需要一些逻辑相关的请求-响应交换来保持状态信息。为了使应用程序能够维持一个过程状态，httpclient允许HTTP请求在一个特定的执行上下文中来执行–称为HTTP上下文。 HttpContext能够包含任意的对象，因此在两个不同的线程中共享上下文是不安全的。建议每个线程都有一个自己的上下文。 在HTTP请求执行的过程中，HttpClient添加了下列属性到执行上下文中： HttpConnection 实例代表连接到目标服务器的当前连接 HttpHost 实例代表连接到目标服务器的当前连接 HttpRoute 实例代表了完整的连接路由 HttpRequest 实例代表了当前的HTTP请求。 HttpResponse 实例代表了当前的HTTP响应。 RequestConfig 代表当前请求配置。 java.util.List 对象代表一个含有执行请求过程中所有重定向的地址。 小demo请求配置在最初被初始化，它将在执行上下文中一直保持，共享同一个会话的所有连续请求12345678910111213141516171819public static void contextDemo() throws IOException &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); RequestConfig config = RequestConfig .custom() .setConnectionRequestTimeout(3000) .setConnectTimeout(3000) .setSocketTimeout(3000) .build(); HttpGet get = new HttpGet(&quot;http://www.baidu.com&quot;); get.setConfig(config); HttpClientContext context = HttpClientContext.create(); CloseableHttpResponse response = httpclient.execute(get, context); System.out.println(EntityUtils.toString(response.getEntity())); System.out.println(&quot;---------------------------------&quot;); HttpGet get1 = new HttpGet(&quot;http://www.qq.com&quot;); get1.setConfig(config); CloseableHttpResponse res = httpclient.execute(get1, context); System.out.println(EntityUtils.toString(res.getEntity())); &#125; 异常处理HttpClient 能够抛出两种类型的异常： java.io.IOException ,如socket 连接超时或被重置的异常。 HttpException :标志Http请求失败的信号，如违反HTTP协议。 I/O 错误被认为是非致命的和可以恢复的，而HTTP协议错误，则被认为是致命的而且是不能自动恢复的。 请求尝试处理器 为了能使用自定义异常的回复机制，必须要实现HttpRequestRetryHandler接口。 小demo123456789public static void requestRetryDemo() throws IOException &#123; CloseableHttpClient httpClient = HttpClients .custom() .setRetryHandler(DefaultHttpRequestRetryHandler.INSTANCE) .build(); HttpGet get = new HttpGet(&quot;http://www.baidu.com&quot;) ; CloseableHttpResponse response = httpClient.execute(get); System.out.println(EntityUtils.toString(response.getEntity())); &#125; 上例中我们使用了默认的请求重试类，默认重试次数为三次，requestSentRetryEnabled 为false，当然我们也可以自己定制,具体的参数请自行查阅源码 请求终止 使用HttpRequest#abort()来终止线程 ;该方法为线程安全的，可以从任意线程调用。 重定向处理 重定向的url,通过HttpContext#getRedirectLocation().获取重定向网址。 参考： http://blog.csdn.net/u011179993/article/details/47123727]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[httpclient 4.5.2 学习随笔（1）]]></title>
      <url>%2F2016%2F12%2F19%2Fhttpclient-4-5-2-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[疑惑的地方刚开始接触httpclient的同学可能会比较疑惑，因为你发现创建httpclient的方式有两种： HttpClient client = new HttpClient(); CloseableHttpClient httpclient = HttpClients.createDefault(); 到底该使用那种方式来创建httpclient，或者使用httpclient 又该导入哪些包。标号1中，是commons-httpclient 版本的创建方式，标号2是 httpclient的版本。这两个版本都可以处理http请求。我查阅了一下apach的官网看到了这样的一句话： The Commons HttpClient project is now end of life, and is no longer being developed. It has been replaced by the Apache HttpComponents project in its HttpClient and HttpCore modules, which offer better performance and more flexibility.大意是commons-httpclient项目不再提供更新和开发。看着这句话我们应该明白了，以后HttpClient client = new HttpClient() 这种创建httpclient 的方式，也应该会被我们弃用掉。新建的项目还是使用httpclient 吧。 之所以写这篇文档，也算是给自己做一个记录吧，httpclient4.5的版本变化还是比较大的，网络上的很多文档都是基于4.4写的，有点过时了。在学习官方文档，教程，源码的基础上，给自己留下一个学习的小脚印。 序言 HTTP也许是当今互联网上使用的最重要的协议了，尽管java.net包提供了访问HTTP资源的基本功能，但是因为它的不够灵活，使得Httpclient的应用更加广泛。HttpClient 不是一个浏览器，它是一个客户端的HTTP通信实现库，httpclient的目标是发送和接收报文。 小Demo提供一个小demo ,看看这个httpclient到底该怎么用。 pom.xml文件中导入jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt; demo 程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import org.apache.http.Consts;import org.apache.http.HttpStatus;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;/** * describe * * @Author: soul * @Date: 2016/12/5 * @since: JDK 1.8 * @Version: v1.0 */public class Demo &#123; public static void main(String[] args) throws IOException, URISyntaxException &#123; example(); &#125; public static void example() throws URISyntaxException, IOException &#123; //创建httpclient实例，采用默认的参数配置 CloseableHttpClient httpClient = HttpClients.createDefault(); //通过URIBuilder类创建URI URI uri = new URIBuilder().setScheme(&quot;http&quot;) .setHost(&quot;www.baidu.com&quot;) .build(); HttpGet get = new HttpGet(uri) ; //使用Get方法提交 //请求的参数配置，分别设置连接池获取连接的超时时间，连接上服务器的时间，服务器返回数据的时间 RequestConfig config = RequestConfig.custom() .setConnectionRequestTimeout(3000) .setConnectTimeout(3000) .setSocketTimeout(3000) .build(); //配置信息添加到Get请求中 get.setConfig(config); //通过httpclient的execute提交 请求 ，并用CloseableHttpResponse接受返回信息 CloseableHttpResponse response = httpClient.execute(get); //服务器返回的状态 int statusCode = response.getStatusLine().getStatusCode() ; //判断返回的状态码是否是200 ，200 代表服务器响应成功，并成功返回信息 if(statusCode == HttpStatus.SC_OK)&#123; //EntityUtils 获取返回的信息。官方不建议使用使用此类来处理信息 System.out.println(&quot;Demo.example --------&gt;&quot; + EntityUtils.toString(response.getEntity() , Consts.UTF_8)); &#125;else &#123; System.out.println(&quot;Demo.example --------&gt;&quot; + &quot;获取信息失败&quot;); &#125; &#125;&#125; 上面的程序基本上能满足一些简单的数据请求。总结下httpclient的使用步骤： 创建httpclient实例 创建httpmethod 方法实例 ，最常用的是HttpGet,HttpPost 类 httpclient 通过execute方法提交Get 或者Post 请求 使用CloseableHttpResponse 来接受服务器返回的状态信息和实体信息 关闭连接 HTTP 请求 所有的HTTP请求都有一个请求的起始行，由方法名，uri和HTTP协议版本组成 。HttpClient很好的支持了HTTP/1.1规范中所有的HTTP方法：GET，HEAD,POST ,PUT ,DELETE ,TRACE 和 OPTIONS。每个方法都对应一个类：HttpGet,HttpHead,HttpPost,HttpPut,HttpDelete,HttpTrace和HttpOptions。uri-&gt;统一资源定位符，包含了协议名称（http,https,ftp）,主机名（www.xxx.com,www.xx.cn）,可选端口（如果为80端口，可以省略），资源路径（/search）,可选参数，可选片段等。url如下： http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq= HttpClient提供了URIBuilder工具类来简化创建。修改request URI .1234567891011URI uri = new URIBuilder().setScheme(&quot;http&quot;) .setHost(&quot;www.google.com&quot;) .setPath(&quot;/search&quot;) .setParameter(&quot;q&quot; ,&quot;httpclient&quot;) .setParamter(&quot;btnG&quot; ,&quot;google+Serach&quot;) .build() ;HttpGet get = new HttpGet(uri) ;//除了使用URIBuilder工具类来创建连接，也可以直接采用字符串来定义uriString url = http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq ；HttpGet get = new HttpGet(url); //效果也是一样的 Http 响应 HTTP响应是服务器接收并解析请求信息后返回给客户端的信息，它的起始行包含了一个协议版本，一个状态和描述状态的短语。Http/1.1 , 200 ,Ok HTTP 实体 HttpClient 分为三种实体： 流式实体：内容来源于一个流，或者在运行中产生。流式实体不可重复。 自我包含：内存中的内容，通过独立的链接/其他的实体获得的内容。自我包含实体可重复 包装实体：从另外一个实体中获得内容。 服务器返回的信息封装在了entity中，客户端通过调用response.getEntity 可以拿到该实体内容。通过HttpEntity#getContent()方法，可以将数据转换成一个InputStream流。或者提供一个输出流给HttpEntity#writeTo(Outputstream)方法，它将会返回写入给定流的所有内容。官方其实是不建议使用EntityUtils类的，除非响应的实体来自于信任的Http服务器，并且知道它的长度。 释放低级别的资源 为了确保正确的释放资源，你必须关掉与实体相关的内容流，还必须关掉响应流。 inputStrea.close() response.close() 参考： http://blog.csdn.net/u011179993/article/details/47123727]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Http 协议简析]]></title>
      <url>%2F2016%2F12%2F18%2FHttp-%E5%8D%8F%E8%AE%AE%E7%AE%80%E6%9E%90%2F</url>
      <content type="text"><![CDATA[引言HTTP是一个属于应用层的面向兑现的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它与1990年提出。目前使用的版本是HTTP/1.1版本。 HTTP协议 协议是指两台计算机之间进行通信必须共同遵守的规定或者规则。超文本传输协议是一种通信协议，它允许将超文本标记语言文档从web服务器传送到客户端的浏览器。特点 支持客户端/服务器模式（C/S）。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是每次连接只能处理一个请求。服务器处理完客户的请求后，并受到客户的应答，即断开连接。 无状态：HTTP协议是无状态的。无状态是指协议对于事务处理没有记忆能力。本次的请求和上一次请求并没有关系，对于服务器来说，并不知道两次请求来自同一个客户端。 WEB浏览器、服务器、代理服务器 当我们输入网址之后，就能看到网页，原理是怎样的呢，简单的解析一下： 客户端与服务端通过http协议建立连接。 连接建立之后，发送request请求，请求格式为：URL，协议的版本号，客户机信息等内容。 服务器受到请求之后，作为响应，返回客户端的请求内容。 客户端浏览器收到服务的信息后，解析内容，显示在浏览器界面上。 请求过程如下面图片所示： 我们的请求又可能不是通过客户端直接和服务端连接的，中间可能会加一个代理的服务器，客户端先和代理服务器连接，之后在和目标服务器连接，这样可以隐藏客户端的ip,这种方式在爬虫中比较常用，它可以提高访问的速度，突破封锁的限制，隐藏客户端的信息。请求过程如下图所示： HTTP代理服务器简单说，http代理服务器就是网络信息的中转站，代理服务器具有缓存的功能，有很大的存储空间。对于客户端来说，代理服务器相当于服务端，对于都服务端来说，代理服务器就是要一个客户端。 HTTP URL组成解析 URL描述的是网络上的资源，任何信息都可以通过URL找到它。http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 格式如下： http://www.test.com/search/yuluo?id=1234&amp;name=zhangsan scheme 指定底层使用的协议（http ,https ,ftp） host 服务器的ip地址，域名 ,上例中的 www.test.con port 端口号 一般默认是80 可以不写 ，若是其他端口，如8080 必须要书写. path 访问的资源路径 /search/yuluo query-string 发送给http的数据 id=1234&amp;name=zhangsan HTTP消息结构 request-line 请求行:请求的种类，请求的路径，http协议版本 http header ：http 头部信息 body ： 发送给服务器的query信息 当时用Get方法的时候，body是空的 Get： Host: Accept : 浏览器可以接受的媒体类型 / 任意类型 Accept-Encoding： 申明自己接收的编码方法 Accept-Language： 申明自己接收的语言 Cache-Control：Response-Request遵循的缓存机制 Cookie： 将cookie的值发送给服务器 Referer: User-Agent：客户端使用的系统和浏览器的版本 Post 请求 Post： Host： Accept： Accept-Encoding： Accept-Language: Cache-Control: Cookie: Referer: User-Agent: body : Get和Post请求的区别 Get 一般用于获取/查询资源信息，请求参数携带在url中Post 一般用于更新资源信息 ，url中无参数信息 请求方法 GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 常用状态码 200 OK : 表明响应成功，所请求的资源发给浏览器 302 found : 重定向，新的请求放在了Location中，浏览器从Location中提取连接欸，重新请求。 400 Bad Request : 客户端的请求，不能被服务器所理解 401 Unauthorized : 请求未经授权 403 Forbidden : 服务器收到请求，拒绝提供服务 404 Not Found : 找不到请求资源 500 Internal Server Error : 服务器错误 503 Server Unavailable 服务器当前不能处理请求 响应消息 客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误的编码、实体元信息以及必要的实体内容。包括： 状态行 消息报头 响应正文 响应报头 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头 LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。 ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。 HTTP无状态问题 通过Cookie 保存状态信息 。每次请求的时候携带cookie的信息，服务端就可以知道你来自同一个浏览器。 通过session 保存状态信息。session是一种服务器端的机制。 cookie和session的区别 cookie状态保存在客户端，session状态保存在服务器端 cookie是服务器端在客户端机上存储的一小段文本，并随每次请求一起发送到服务端 session是针对每一个用户，变量值保存在服务器中 从安全角度讲，session的安全性更好一些]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客主题配置、定制]]></title>
      <url>%2F2016%2F12%2F12%2F%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E3%80%81%E5%AE%9A%E5%88%B6%2F</url>
      <content type="text"><![CDATA[上一篇文章中，成功的完成了博客的搭建，不得不说，就我个人来言，官方默认的主题真实太丑，作为一个追求简约，喜欢简单布局的人，真的是一种精神折磨，太让人受不了了。经过比较最终选择了精于心，简于形的Next主题。站点和主题都有配置文件_config.yml ，为了便于区分，博客根目录的配置文件我们称为站点配置，主题的配置文件我们称为主题配置文件。 主题替换 下载主题 进人你博客的根目录，运行Git Bash Here 。输入：1git clone https://github.com/iissnan/hexo-theme-next themes/next 主题下载完成后，将文件夹改名为next 。 切换主题 打开博客根目录，找到_config.yml 。 找到 theme 字段，并将其值更改为 next。 theme 和 next 之间有空格!! 1theme: next 保存之后，我们的主题已经替换完成了，在本地验证一下，在运行之前，先运行hexo clean 清楚一下缓存，运行 hexo g 生成一下，最后运行hexo s 。在浏览器输入网址，http://localhost:4000, 验证一下效果。效果图如下：说明替换成功了。 主题设定 NexT 有三种Scheme,他们是： Muse - 默认 Mist - 紧凑版本 Pisces - 双栏Scheme,小家碧玉似的清新 设定方法是： 切换到 next 文件夹 ， 打开_config.yml配置文件 1234# Schemesscheme: Muse#scheme: Mist#scheme: Pisces 将注释去掉就可以切换scheme了。 设置语言 站点配置文件更改语言： language: zh-Hans , 改为中文。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建个人博客]]></title>
      <url>%2F2016%2F12%2F12%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言 很久之前就像要一个自己的博客，想在这个浩瀚的网络上，能有一个自己的小家，简单的写写文章，记录一下自己的心路历程。虽然有各种博客，但是风格都是官方定好的，完全没有自己发挥的空间。 虽然wordpress可以搭建个人博客，但是服务器空间域名等都需要钱来维护，而且wordpress使用起来也不是很爽。直到发现了githubpage和hexo。一颗躁动的心又要起航了。概述 github： 是一个面向开源及私有软件项目的托管平台，只支持git作为唯一的版本库格式进行托管，故名GitHub 。也是众多程序员聚集的地方,目前拥有超过 900 万的开发用户。 node.js： Node是一个服务端JavaScript解析器，他将改变服务器如何工作的概念。目标是帮助程序员构建可伸缩的应用程序，虽然说了这么多，我能说其实我也不会用吗 。。。 git: 一款免费的开源的分布式版本控制系统，用于敏捷高效的处理任何或小或大的项目 Hexo: 一款基于NODE.JS的快速、简单的博客框架，能够创建一个项目进行编辑后生成一套静态网页，比较适合个人博客的搭建。可以急速生成静态网页，支持MarkDown。 github pages : 300M免费空间，资料可以自己管理，免费使用，并且快速稳定。 软件下载地址传送门 node.js : https://nodejs.org/en/download/git : https://github.com/git-for-windows/git/releases/tag/v2.11.0.windows.1 环境安装 安装node.js， 我下载的是 .msi 的安装包， 软件会默认将安装路径添加到path中。 安装git，如果不会安装，请自行搜索教程 本机环境 windows 8.1 git版本： version 2.10.1.windows.1 nodejs版本： v6.9.2 实战开始 安装 配装 使用 Hexo Hexo需要的环境搭建好之后，我们开始安装hexo 。 安装Hexo 在电脑的任意位置，创建一个文件夹，文字随便命名看你喜欢了，鼠标右键，点击Git Bash Here ,输入命令即可安装 。 npm install -g hexo npm install hexo –save hexo init npm install npm install hexo-deployer-git –save //ERROR Deployer not found: git 安装这个插件 安装成功的目录： 本地查看运行效果： 运行命令： hexo generate 命令简写 hexo ghexo server 命令简写 hexo s 浏览器运行结果： 在浏览器输入 http://localhost:4000 , 即可看到本地的运行的效果。 淘宝源安装 npm install -g cnpm –registry=https://registry.npm.taobao.org之后的安装就是把npm install 换成 cnpm install 看到上面的图片，说明我们hexo本地的安装已经成功，接下来就是将我们的文件上传到github了，首先我们需要有一个github账号，直接去注册就好了，作为一个屌丝程序员，怎么可能没有github账号，之后就是设置ssh公钥，设置的方式： 登陆账号后，鼠标点击你的头像，点击-Your profile 点击左边的 ， Edit profile 左边，SSH and GPG keys 右边，New SSH key 随便输入 title , key 文本框中，输入公钥，点击Add SSH key 创建仓库 New repository ， 创建新仓库 Repository name ,这个是重点 ！！一点要填写为：你的账号名.github.io 。 完成仓库的创建 。 结果如下图： 部署到github 仓库创建成功以后，我们可以将本地的网页文件上传到github了，下面我们看一下具体的设置： 打开,你创建文件夹的根目录 ，找到 _config.yml文件 ，在最后面添加下面的代码： 1234deploy: type: git repository: 你的仓库地址 branch: master hexo 的配置已经完成。 接下来，我们使用hexo命令将文件上传到github仓库中。 123hexo clean # 清楚缓存hexo g # 生成静态网页至public目录hexo d # 发布到github 效果如下图说明发布成功 在浏览器输入 Your-Github-Name.github.io ,就可以查看你的博客了。 到这里，博客已经基本创建好了，后续会继续跟进博客主题的替换，博客样式的设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F12%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
