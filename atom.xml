<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Topyuluo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.github.com/topyuluo/"/>
  <updated>2016-12-28T16:13:41.492Z</updated>
  <id>http://www.github.com/topyuluo/</id>
  
  <author>
    <name>YuLuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>httpclient 4.5.2 学习随笔（2）</title>
    <link href="http://www.github.com/topyuluo/2016/12/29/httpclient-4-5-2-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%EF%BC%882%EF%BC%89/"/>
    <id>http://www.github.com/topyuluo/2016/12/29/httpclient-4-5-2-学习随笔（2）/</id>
    <published>2016-12-28T16:12:36.000Z</published>
    <updated>2016-12-28T16:13:41.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><p>许多应用需要模仿一个登陆HTML表单的过程，比如：为了登陆一个WEB应用或者提交输入的数据。Httpclient 早就为我们准备好了，提供了UrlEncodedFormEntity类来简化操作。<br>我们来看一下核心的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;NameValuePair&gt; list = new ArrayList&lt;&gt;() ;</div><div class="line">list.add(new BasicNameValuePair(&quot;name&quot; ,&quot;zhangsan&quot;));</div><div class="line">list.add(new BasicNameValuePair(&quot;age&quot; ,&quot;18&quot;));</div><div class="line">UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(list ,Consts.UTF_8) ;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>post方法提交demo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import org.apache.http.Consts;</div><div class="line">import org.apache.http.HttpStatus;</div><div class="line">import org.apache.http.NameValuePair;</div><div class="line">import org.apache.http.client.entity.UrlEncodedFormEntity;</div><div class="line">import org.apache.http.client.methods.CloseableHttpResponse;</div><div class="line">import org.apache.http.client.methods.HttpPost;</div><div class="line">import org.apache.http.impl.client.CloseableHttpClient;</div><div class="line">import org.apache.http.impl.client.HttpClients;</div><div class="line">import org.apache.http.message.BasicNameValuePair;</div><div class="line">import org.apache.http.util.EntityUtils;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by YuLuo on 2016/12/5.</div><div class="line"> */</div><div class="line">public class PostDemo &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        demo();</div><div class="line">    &#125;</div><div class="line">    public static void demo() throws IOException &#123;</div><div class="line">        //创建httpclient 实例</div><div class="line">        CloseableHttpClient httpclient = HttpClients.createDefault();</div><div class="line">        //创建post方法实例</div><div class="line">        HttpPost post = new HttpPost(&quot;http://host/.com&quot;) ;</div><div class="line"></div><div class="line">        //封装提交到服务器的参数信息</div><div class="line">        List&lt;NameValuePair&gt; list = new ArrayList&lt;&gt;() ;</div><div class="line">        list.add(new BasicNameValuePair(&quot;name&quot; ,&quot;zhangsan&quot;));</div><div class="line">        list.add(new BasicNameValuePair(&quot;age&quot; ,&quot;18&quot;));</div><div class="line">        UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(list , Consts.UTF_8) ;</div><div class="line">        //设置参数信息</div><div class="line">        post.setEntity(formEntity);</div><div class="line">        //提交post方法</div><div class="line">        CloseableHttpResponse respone = httpclient.execute(post);</div><div class="line"></div><div class="line">        int statcode = respone.getStatusLine().getStatusCode() ;</div><div class="line">        if(statcode == HttpStatus.SC_OK)&#123;</div><div class="line">            System.out.println(EntityUtils.toString(respone.getEntity()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>解析NameValuePair </strong><br>通过查看源码，发现NameValuePair只有两个方法：</p>
<ol>
<li>getName()</li>
<li>getValue()</li>
</ol>
<p>BasicNameValuePair作为NameValuePair的实现类，只有两个字段，Name和Value ，并且它还实现了Cloneable ，Serializable 两个接口。BasicNameValuePair 没有提供属性的setter方法。只能通过构造方法，为字段赋值。</p>
<p><strong>内容分块</strong></p>
<p>通过HTTP#setChunded()方法来通知HttpClient你要进行分块处理， 由Httpclient根据被传输的报文属性选择最合适的传输编码方式。当使用一些不支持分块的版本（http /1.0）时，这个值会被忽略掉。</p>
<p><strong>Http执行上下文 context</strong></p>
<p>最初，HTTP是被设计成无状态的，面向请求-响应协议。然而，我们在使用的过程中，经常需要一些逻辑相关的请求-响应交换来保持状态信息。为了使应用程序能够维持一个过程状态，httpclient允许HTTP请求在一个特定的执行上下文中来执行–称为HTTP上下文。</p>
<p><em>HttpContext能够包含任意的对象，因此在两个不同的线程中共享上下文是不安全的。建议每个线程都有一个自己的上下文。</em></p>
<p>在HTTP请求执行的过程中，HttpClient添加了下列属性到执行上下文中：</p>
<ul>
<li>HttpConnection 实例代表连接到目标服务器的当前连接</li>
<li>HttpHost 实例代表连接到目标服务器的当前连接</li>
<li>HttpRoute 实例代表了完整的连接路由</li>
<li>HttpRequest 实例代表了当前的HTTP请求。</li>
<li>HttpResponse 实例代表了当前的HTTP响应。</li>
<li>RequestConfig 代表当前请求配置。</li>
<li>java.util.List<uri> 对象代表一个含有执行请求过程中所有重定向的地址。</uri></li>
</ul>
<p><strong>小demo</strong><br>请求配置在最初被初始化，它将在执行上下文中一直保持，共享同一个会话的所有连续请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static void contextDemo() throws IOException &#123;</div><div class="line">       CloseableHttpClient httpclient = HttpClients.createDefault();</div><div class="line">       RequestConfig config = RequestConfig</div><div class="line">                                       .custom()</div><div class="line">                                       .setConnectionRequestTimeout(3000)</div><div class="line">                                       .setConnectTimeout(3000)</div><div class="line">                                       .setSocketTimeout(3000)</div><div class="line">                                       .build();</div><div class="line">       HttpGet get = new HttpGet(&quot;http://www.baidu.com&quot;);</div><div class="line">       get.setConfig(config);</div><div class="line">       HttpClientContext context = HttpClientContext.create();</div><div class="line">       CloseableHttpResponse response = httpclient.execute(get, context);</div><div class="line">       System.out.println(EntityUtils.toString(response.getEntity()));</div><div class="line">       System.out.println(&quot;---------------------------------&quot;);</div><div class="line">       HttpGet get1 = new HttpGet(&quot;http://www.qq.com&quot;);</div><div class="line">       get1.setConfig(config);</div><div class="line">       CloseableHttpResponse res = httpclient.execute(get1, context);</div><div class="line">       System.out.println(EntityUtils.toString(res.getEntity()));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><strong>异常处理</strong><br>HttpClient 能够抛出两种类型的异常：</p>
<ol>
<li>java.io.IOException ,如socket 连接超时或被重置的异常。</li>
<li>HttpException :标志Http请求失败的信号，如违反HTTP协议。</li>
</ol>
<blockquote>
<p>I/O 错误被认为是非致命的和可以恢复的，而HTTP协议错误，则被认为是致命的而且是不能自动恢复的。</p>
</blockquote>
<p><strong>请求尝试处理器</strong></p>
<p>为了能使用自定义异常的回复机制，必须要实现HttpRequestRetryHandler接口。</p>
<p><strong>小demo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void requestRetryDemo() throws IOException &#123;</div><div class="line">        CloseableHttpClient httpClient = HttpClients</div><div class="line">                .custom()</div><div class="line">                .setRetryHandler(DefaultHttpRequestRetryHandler.INSTANCE)</div><div class="line">                .build();</div><div class="line">        HttpGet get = new HttpGet(&quot;http://www.baidu.com&quot;) ;</div><div class="line">        CloseableHttpResponse response = httpClient.execute(get);</div><div class="line">        System.out.println(EntityUtils.toString(response.getEntity()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><em>上例中我们使用了默认的请求重试类，默认重试次数为三次，requestSentRetryEnabled 为false，当然我们也可以自己定制,具体的参数请自行查阅源码</em></p>
<p><strong>请求终止</strong></p>
<p>使用HttpRequest#abort()来终止线程 ;该方法为线程安全的，可以从任意线程调用。</p>
<p><strong>重定向处理</strong></p>
<p>重定向的url,通过HttpContext#getRedirectLocation().获取重定向网址。</p>
<p>参考： <a href="http://blog.csdn.net/u011179993/article/details/47123727" target="_blank" rel="external">http://blog.csdn.net/u011179993/article/details/47123727</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML表单&quot;&gt;&lt;a href=&quot;#HTML表单&quot; class=&quot;headerlink&quot; title=&quot;HTML表单&quot;&gt;&lt;/a&gt;HTML表单&lt;/h3&gt;&lt;p&gt;许多应用需要模仿一个登陆HTML表单的过程，比如：为了登陆一个WEB应用或者提交输入的数据。Httpclient 早就为我们准备好了，提供了UrlEncodedFormEntity类来简化操作。&lt;br&gt;我们来看一下核心的代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;NameValuePair&amp;gt; list = new ArrayList&amp;lt;&amp;gt;() ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;list.add(new BasicNameValuePair(&amp;quot;name&amp;quot; ,&amp;quot;zhangsan&amp;quot;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;list.add(new BasicNameValuePair(&amp;quot;age&amp;quot; ,&amp;quot;18&amp;quot;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(list ,Consts.UTF_8) ;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-HTTP" scheme="http://www.github.com/topyuluo/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://www.github.com/topyuluo/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>httpclient 4.5.2 学习随笔（1）</title>
    <link href="http://www.github.com/topyuluo/2016/12/19/httpclient-4-5-2-%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%EF%BC%881%EF%BC%89/"/>
    <id>http://www.github.com/topyuluo/2016/12/19/httpclient-4-5-2-学习随笔（1）/</id>
    <published>2016-12-19T14:13:04.000Z</published>
    <updated>2016-12-19T14:19:50.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="疑惑的地方"><a href="#疑惑的地方" class="headerlink" title="疑惑的地方"></a>疑惑的地方</h3><p>刚开始接触httpclient的同学可能会比较疑惑，因为你发现创建httpclient的方式有两种：</p>
<ol>
<li><code>HttpClient client = new HttpClient();</code></li>
<li><code>CloseableHttpClient httpclient = HttpClients.createDefault();</code></li>
</ol>
<p>到底该使用那种方式来创建httpclient，或者使用httpclient 又该导入哪些包。标号1中，是commons-httpclient 版本的创建方式，标号2是 httpclient的版本。这两个版本都可以处理http请求。我查阅了一下apach的官网看到了这样的一句话：</p>
<blockquote>
<p>The Commons HttpClient project is now end of life, and is no longer being developed. It has been replaced by the Apache HttpComponents project in its HttpClient and HttpCore modules, which offer better performance and more flexibility.<br><a id="more"></a><br>大意是commons-httpclient项目不再提供更新和开发。看着这句话我们应该明白了，以后HttpClient client = new HttpClient() 这种创建httpclient 的方式，也应该会被我们弃用掉。新建的项目还是使用httpclient 吧。</p>
</blockquote>
<p>之所以写这篇文档，也算是给自己做一个记录吧，httpclient4.5的版本变化还是比较大的，网络上的很多文档都是基于4.4写的，有点过时了。在学习官方文档，教程，源码的基础上，给自己留下一个学习的小脚印。</p>
<p><strong>序言</strong></p>
<p>HTTP也许是当今互联网上使用的最重要的协议了，尽管java.net包提供了访问HTTP资源的基本功能，但是因为它的不够灵活，使得Httpclient的应用更加广泛。HttpClient 不是一个浏览器，它是一个客户端的HTTP通信实现库，httpclient的目标是发送和接收报文。</p>
<p><strong>小Demo</strong><br>提供一个小demo ,看看这个httpclient到底该怎么用。</p>
<ol>
<li><p>pom.xml文件中导入jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</div><div class="line">   &lt;version&gt;4.5.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>demo 程序</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">import org.apache.http.Consts;</div><div class="line">import org.apache.http.HttpStatus;</div><div class="line">import org.apache.http.client.config.RequestConfig;</div><div class="line">import org.apache.http.client.methods.CloseableHttpResponse;</div><div class="line">import org.apache.http.client.methods.HttpGet;</div><div class="line">import org.apache.http.client.utils.URIBuilder;</div><div class="line">import org.apache.http.impl.client.CloseableHttpClient;</div><div class="line">import org.apache.http.impl.client.HttpClients;</div><div class="line">import org.apache.http.util.EntityUtils;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.URI;</div><div class="line">import java.net.URISyntaxException;</div><div class="line"></div><div class="line">/**</div><div class="line"> * describe</div><div class="line"> *</div><div class="line"> * @Author: soul</div><div class="line"> * @Date: 2016/12/5</div><div class="line"> * @since: JDK 1.8</div><div class="line"> * @Version: v1.0</div><div class="line"> */</div><div class="line"></div><div class="line">public class Demo &#123;</div><div class="line">    public static void main(String[] args) throws IOException, URISyntaxException &#123;</div><div class="line">        example();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void example() throws URISyntaxException, IOException &#123;</div><div class="line">        //创建httpclient实例，采用默认的参数配置</div><div class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</div><div class="line">        //通过URIBuilder类创建URI</div><div class="line">        URI uri = new URIBuilder().setScheme(&quot;http&quot;)</div><div class="line">                    .setHost(&quot;www.baidu.com&quot;)</div><div class="line">                    .build();</div><div class="line"></div><div class="line">        HttpGet get = new HttpGet(uri) ;   //使用Get方法提交</div><div class="line"></div><div class="line">        //请求的参数配置，分别设置连接池获取连接的超时时间，连接上服务器的时间，服务器返回数据的时间</div><div class="line">        RequestConfig config = RequestConfig.custom()</div><div class="line">                                           .setConnectionRequestTimeout(3000)</div><div class="line">                                           .setConnectTimeout(3000)</div><div class="line">                                           .setSocketTimeout(3000)</div><div class="line">                                         .build();</div><div class="line">        //配置信息添加到Get请求中</div><div class="line">        get.setConfig(config);</div><div class="line">        //通过httpclient的execute提交 请求 ，并用CloseableHttpResponse接受返回信息</div><div class="line">        CloseableHttpResponse response = httpClient.execute(get);</div><div class="line">        //服务器返回的状态</div><div class="line">        int statusCode = response.getStatusLine().getStatusCode() ;</div><div class="line">        //判断返回的状态码是否是200 ，200 代表服务器响应成功，并成功返回信息</div><div class="line">        if(statusCode == HttpStatus.SC_OK)&#123;</div><div class="line">            //EntityUtils 获取返回的信息。官方不建议使用使用此类来处理信息</div><div class="line">            System.out.println(&quot;Demo.example --------&gt;&quot; + EntityUtils.toString(response.getEntity() , Consts.UTF_8));</div><div class="line">        &#125;else &#123;</div><div class="line">            System.out.println(&quot;Demo.example --------&gt;&quot; + &quot;获取信息失败&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的程序基本上能满足一些简单的数据请求。总结下httpclient的使用步骤：</p>
<ul>
<li>创建httpclient实例</li>
<li>创建httpmethod 方法实例 ，最常用的是HttpGet,HttpPost 类</li>
<li>httpclient 通过execute方法提交Get 或者Post 请求</li>
<li>使用CloseableHttpResponse 来接受服务器返回的状态信息和实体信息</li>
<li>关闭连接</li>
</ul>
<p><strong>HTTP 请求</strong></p>
<p>所有的HTTP请求都有一个请求的起始行，由方法名，uri和HTTP协议版本组成 。<br>HttpClient很好的支持了HTTP/1.1规范中所有的HTTP方法：GET，HEAD,POST ,PUT ,DELETE ,TRACE 和 OPTIONS。每个方法都对应一个类：HttpGet,HttpHead,HttpPost,HttpPut,HttpDelete,HttpTrace和HttpOptions。<br>uri-&gt;统一资源定位符，包含了协议名称（http,https,ftp）,主机名（www.xxx.com,www.xx.cn）,可选端口（如果为80端口，可以省略），资源路径（/search）,可选参数，可选片段等。<br>url如下：</p>
<p><code>http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=</code></p>
<p>HttpClient提供了URIBuilder工具类来简化创建。修改request URI .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">URI uri = new URIBuilder().setScheme(&quot;http&quot;)</div><div class="line">            .setHost(&quot;www.google.com&quot;)</div><div class="line">            .setPath(&quot;/search&quot;)</div><div class="line">            .setParameter(&quot;q&quot; ,&quot;httpclient&quot;)</div><div class="line">            .setParamter(&quot;btnG&quot; ,&quot;google+Serach&quot;)</div><div class="line">            .build() ;</div><div class="line">HttpGet get = new HttpGet(uri) ;</div><div class="line">//除了使用URIBuilder工具类来创建连接，也可以直接采用字符串来定义uri</div><div class="line">String url = http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq ；</div><div class="line">HttpGet get = new HttpGet(url); </div><div class="line">//效果也是一样的</div></pre></td></tr></table></figure></p>
<p><strong>Http 响应</strong></p>
<p>HTTP响应是服务器接收并解析请求信息后返回给客户端的信息，它的起始行包含了一个协议版本，一个状态和描述状态的短语。Http/1.1 , 200 ,Ok </p>
<p><strong>HTTP 实体</strong></p>
<p>HttpClient 分为三种实体：</p>
<ol>
<li>流式实体：内容来源于一个流，或者在运行中产生。流式实体不可重复。</li>
<li>自我包含：内存中的内容，通过独立的链接/其他的实体获得的内容。自我包含实体可重复</li>
<li>包装实体：从另外一个实体中获得内容。</li>
</ol>
<p>服务器返回的信息封装在了entity中，客户端通过调用response.getEntity 可以拿到该实体内容。通过HttpEntity#getContent()方法，可以将数据转换成一个InputStream流。或者提供一个输出流给HttpEntity#writeTo(Outputstream)方法，它将会返回写入给定流的所有内容。官方其实是不建议使用EntityUtils类的，除非响应的实体来自于信任的Http服务器，并且知道它的长度。</p>
<p><strong>释放低级别的资源</strong></p>
<p>为了确保正确的释放资源，你必须关掉与实体相关的内容流，还必须关掉响应流。</p>
<ul>
<li>inputStrea.close()</li>
<li>response.close()</li>
</ul>
<p>参考： <a href="http://blog.csdn.net/u011179993/article/details/47123727" target="_blank" rel="external">http://blog.csdn.net/u011179993/article/details/47123727</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;疑惑的地方&quot;&gt;&lt;a href=&quot;#疑惑的地方&quot; class=&quot;headerlink&quot; title=&quot;疑惑的地方&quot;&gt;&lt;/a&gt;疑惑的地方&lt;/h3&gt;&lt;p&gt;刚开始接触httpclient的同学可能会比较疑惑，因为你发现创建httpclient的方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;HttpClient client = new HttpClient();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CloseableHttpClient httpclient = HttpClients.createDefault();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到底该使用那种方式来创建httpclient，或者使用httpclient 又该导入哪些包。标号1中，是commons-httpclient 版本的创建方式，标号2是 httpclient的版本。这两个版本都可以处理http请求。我查阅了一下apach的官网看到了这样的一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Commons HttpClient project is now end of life, and is no longer being developed. It has been replaced by the Apache HttpComponents project in its HttpClient and HttpCore modules, which offer better performance and more flexibility.&lt;br&gt;
    
    </summary>
    
      <category term="-HTTP" scheme="http://www.github.com/topyuluo/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://www.github.com/topyuluo/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Http 协议简析</title>
    <link href="http://www.github.com/topyuluo/2016/12/18/Http-%E5%8D%8F%E8%AE%AE%E7%AE%80%E6%9E%90/"/>
    <id>http://www.github.com/topyuluo/2016/12/18/Http-协议简析/</id>
    <published>2016-12-18T07:12:05.000Z</published>
    <updated>2016-12-18T07:21:58.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>HTTP是一个属于应用层的面向兑现的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它与1990年提出。目前使用的版本是HTTP/1.1版本。</p>
<p><strong>HTTP协议</strong></p>
<p>协议是指两台计算机之间进行通信必须共同遵守的规定或者规则。超文本传输协议是一种通信协议，它允许将超文本标记语言文档从web服务器传送到客户端的浏览器。<br><a id="more"></a><br><strong>特点</strong></p>
<ol>
<li>支持客户端/服务器模式（C/S）。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是每次连接只能处理一个请求。服务器处理完客户的请求后，并受到客户的应答，即断开连接。</li>
<li>无状态：HTTP协议是无状态的。无状态是指协议对于事务处理没有记忆能力。本次的请求和上一次请求并没有关系，对于服务器来说，并不知道两次请求来自同一个客户端。</li>
</ol>
<p><strong>WEB浏览器、服务器、代理服务器</strong></p>
<p>当我们输入网址之后，就能看到网页，原理是怎样的呢，简单的解析一下：</p>
<ol>
<li>客户端与服务端通过http协议建立连接。</li>
<li>连接建立之后，发送request请求，请求格式为：URL，协议的版本号，客户机信息等内容。</li>
<li>服务器受到请求之后，作为响应，返回客户端的请求内容。</li>
<li>客户端浏览器收到服务的信息后，解析内容，显示在浏览器界面上。</li>
</ol>
<p>请求过程如下面图片所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2192701-ac38e0e516acfca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求.png"></p>
<p>我们的请求又可能不是通过客户端直接和服务端连接的，中间可能会加一个代理的服务器，客户端先和代理服务器连接，之后在和目标服务器连接，这样可以隐藏客户端的ip,这种方式在爬虫中比较常用，它可以提高访问的速度，突破封锁的限制，隐藏客户端的信息。请求过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2192701-588e277076cbb425.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
<p><strong>HTTP代理服务器</strong><br>简单说，http代理服务器就是网络信息的中转站，代理服务器具有缓存的功能，有很大的存储空间。对于客户端来说，代理服务器相当于服务端，对于都服务端来说，代理服务器就是要一个客户端。</p>
<p><strong>HTTP URL组成解析</strong></p>
<p>URL描述的是网络上的资源，任何信息都可以通过URL找到它。http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</p>
<p>格式如下：</p>
<p><em><a href="http://www.test.com/search/yuluo?id=1234&amp;name=zhangsan" target="_blank" rel="external">http://www.test.com/search/yuluo?id=1234&amp;name=zhangsan</a></em></p>
<ol>
<li>scheme 指定底层使用的协议（http ,https ,ftp）</li>
<li>host   服务器的ip地址，域名 ,上例中的 www.test.con</li>
<li>port   端口号 一般默认是80 可以不写 ，若是其他端口，如8080 必须要书写.</li>
<li>path   访问的资源路径 /search/yuluo</li>
<li>query-string 发送给http的数据 id=1234&amp;name=zhangsan</li>
</ol>
<p><strong>HTTP消息结构</strong></p>
<ul>
<li>request-line 请求行:请求的种类，请求的路径，http协议版本</li>
<li>http header ：http 头部信息</li>
<li>body ： 发送给服务器的query信息</li>
</ul>
<p>当时用Get方法的时候，body是空的</p>
<ol>
<li>Get：</li>
<li>Host:</li>
<li>Accept : 浏览器可以接受的媒体类型 <em>/</em> 任意类型</li>
<li>Accept-Encoding： 申明自己接收的编码方法</li>
<li>Accept-Language： 申明自己接收的语言</li>
<li>Cache-Control：Response-Request遵循的缓存机制</li>
<li>Cookie： 将cookie的值发送给服务器</li>
<li>Referer: </li>
<li>User-Agent：客户端使用的系统和浏览器的版本</li>
</ol>
<hr>
<p>Post 请求</p>
<ol>
<li>Post：</li>
<li>Host：</li>
<li>Accept：</li>
<li>Accept-Encoding：</li>
<li>Accept-Language:</li>
<li>Cache-Control:</li>
<li>Cookie:</li>
<li>Referer:</li>
<li>User-Agent:</li>
<li>body :</li>
</ol>
<p><strong>Get和Post请求的区别</strong></p>
<p>Get 一般用于获取/查询资源信息，请求参数携带在url中<br>Post 一般用于更新资源信息 ，url中无参数信息</p>
<p><strong>请求方法</strong></p>
<ul>
<li>GET     请求获取Request-URI所标识的资源</li>
<li>POST    在Request-URI所标识的资源后附加新的数据</li>
<li>HEAD    请求获取由Request-URI所标识的资源的响应消息报头</li>
<li>PUT     请求服务器存储一个资源，并用Request-URI作为其标识</li>
<li>DELETE  请求服务器删除Request-URI所标识的资源</li>
<li>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断</li>
<li>CONNECT 保留将来使用</li>
<li>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</li>
</ul>
<p><strong>常用状态码</strong></p>
<ul>
<li>200 OK : 表明响应成功，所请求的资源发给浏览器</li>
<li>302 found : 重定向，新的请求放在了Location中，浏览器从Location中提取连接欸，重新请求。</li>
<li>400 Bad Request : 客户端的请求，不能被服务器所理解</li>
<li>401 Unauthorized : 请求未经授权</li>
<li>403 Forbidden : 服务器收到请求，拒绝提供服务</li>
<li>404 Not Found : 找不到请求资源</li>
<li>500 Internal Server Error : 服务器错误</li>
<li>503 Server Unavailable 服务器当前不能处理请求</li>
</ul>
<p><strong>响应消息</strong></p>
<p>客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误的编码、实体元信息以及必要的实体内容。包括：</p>
<ul>
<li>状态行</li>
<li>消息报头</li>
<li>响应正文</li>
</ul>
<p><strong>响应报头</strong></p>
<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>
<p><strong>常用的响应报头</strong></p>
<ul>
<li>Location<br>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。</li>
<li>Server<br>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。</li>
</ul>
<p><strong>HTTP无状态问题</strong></p>
<ol>
<li>通过Cookie 保存状态信息 。每次请求的时候携带cookie的信息，服务端就可以知道你来自同一个浏览器。</li>
<li>通过session 保存状态信息。session是一种服务器端的机制。</li>
</ol>
<p><strong>cookie和session的区别</strong></p>
<ol>
<li>cookie状态保存在客户端，session状态保存在服务器端</li>
<li>cookie是服务器端在客户端机上存储的一小段文本，并随每次请求一起发送到服务端</li>
<li>session是针对每一个用户，变量值保存在服务器中</li>
<li>从安全角度讲，session的安全性更好一些</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;HTTP是一个属于应用层的面向兑现的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它与1990年提出。目前使用的版本是HTTP/1.1版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协议是指两台计算机之间进行通信必须共同遵守的规定或者规则。超文本传输协议是一种通信协议，它允许将超文本标记语言文档从web服务器传送到客户端的浏览器。&lt;br&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://www.github.com/topyuluo/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://www.github.com/topyuluo/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>博客主题配置、定制</title>
    <link href="http://www.github.com/topyuluo/2016/12/12/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E3%80%81%E5%AE%9A%E5%88%B6/"/>
    <id>http://www.github.com/topyuluo/2016/12/12/博客主题配置、定制/</id>
    <published>2016-12-12T13:12:41.000Z</published>
    <updated>2016-12-13T14:14:43.814Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，成功的完成了博客的搭建，不得不说，就我个人来言，官方默认的主题真实太丑，作为一个追求简约，喜欢简单布局的人，真的是一种精神折磨，太让人受不了了。经过比较最终选择了精于心，简于形的Next主题。站点和主题都有配置文件_config.yml ，为了便于区分，博客根目录的配置文件我们称为站点配置，主题的配置文件我们称为主题配置文件。</p>
<a id="more"></a>
<p><strong>主题替换</strong></p>
<ol>
<li>下载主题</li>
</ol>
<p>进人你博客的根目录，运行Git Bash Here 。输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure></p>
<p>主题下载完成后，将文件夹改名为next 。</p>
<ol>
<li>切换主题</li>
</ol>
<p>打开博客根目录，找到_config.yml 。 找到 theme 字段，并将其值更改为 next。 theme 和 next 之间有空格!!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next</div></pre></td></tr></table></figure>
<p>保存之后，我们的主题已经替换完成了，在本地验证一下，在运行之前，先运行<em>hexo clean</em> 清楚一下缓存，运行 <em>hexo g</em> 生成一下，最后运行<em>hexo s</em> 。在浏览器输入网址，<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>, 验证一下效果。效果图如下：说明替换成功了。</p>
<p><img src="http://ohzdad2hw.bkt.clouddn.com/next.png" alt=""></p>
<p><strong>主题设定</strong></p>
<p>NexT 有三种Scheme,他们是：</p>
<ul>
<li>Muse - 默认</li>
<li>Mist - 紧凑版本</li>
<li>Pisces - 双栏Scheme,小家碧玉似的清新</li>
</ul>
<p>设定方法是：</p>
<p>切换到 next 文件夹 ， 打开_config.yml配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Schemes</div><div class="line">scheme: Muse</div><div class="line">#scheme: Mist</div><div class="line">#scheme: Pisces</div></pre></td></tr></table></figure>
<p>将注释去掉就可以切换scheme了。</p>
<p><strong>设置语言</strong></p>
<p>站点配置文件更改语言： language: zh-Hans , 改为中文。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中，成功的完成了博客的搭建，不得不说，就我个人来言，官方默认的主题真实太丑，作为一个追求简约，喜欢简单布局的人，真的是一种精神折磨，太让人受不了了。经过比较最终选择了精于心，简于形的Next主题。站点和主题都有配置文件_config.yml ，为了便于区分，博客根目录的配置文件我们称为站点配置，主题的配置文件我们称为主题配置文件。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.github.com/topyuluo/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://www.github.com/topyuluo/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="http://www.github.com/topyuluo/2016/12/12/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.github.com/topyuluo/2016/12/12/搭建个人博客/</id>
    <published>2016-12-12T13:11:02.000Z</published>
    <updated>2016-12-13T14:14:33.246Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p>
<p>很久之前就像要一个自己的博客，想在这个浩瀚的网络上，能有一个自己的小家，简单的写写文章，记录一下自己的心路历程。虽然有各种博客，但是风格都是官方定好的，完全没有自己发挥的空间。 虽然wordpress可以搭建个人博客，但是服务器空间域名等都需要钱来维护，而且wordpress使用起来也不是很爽。直到发现了githubpage和hexo。一颗躁动的心又要起航了。<br><a id="more"></a><br><strong>概述</strong></p>
<p>github： 是一个面向开源及私有软件项目的托管平台，只支持git作为唯一的版本库格式进行托管，故名GitHub 。也是众多程序员聚集的地方,目前拥有超过 900 万的开发用户。</p>
<p>node.js： Node是一个服务端JavaScript解析器，他将改变服务器如何工作的概念。目标是帮助程序员构建可伸缩的应用程序，虽然说了这么多，我能说其实我也不会用吗 。。。</p>
<p>git: 一款免费的开源的分布式版本控制系统，用于敏捷高效的处理任何或小或大的项目</p>
<p>Hexo: 一款基于NODE.JS的快速、简单的博客框架，能够创建一个项目进行编辑后生成一套静态网页，比较适合个人博客的搭建。可以急速生成静态网页，支持MarkDown。</p>
<p>github pages : 300M免费空间，资料可以自己管理，免费使用，并且快速稳定。</p>
<p><strong>软件下载地址传送门</strong></p>
<p>node.js : <a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a><br>git : <a href="https://github.com/git-for-windows/git/releases/tag/v2.11.0.windows.1" target="_blank" rel="external">https://github.com/git-for-windows/git/releases/tag/v2.11.0.windows.1</a></p>
<p><strong>环境安装</strong></p>
<ul>
<li>安装node.js， 我下载的是 .msi 的安装包， 软件会默认将安装路径添加到path中。</li>
<li>安装git，如果不会安装，请自行搜索教程</li>
</ul>
<p><strong>本机环境</strong></p>
<ol>
<li>windows 8.1</li>
<li>git版本： version 2.10.1.windows.1</li>
<li>nodejs版本： v6.9.2</li>
</ol>
<p><strong>实战开始 安装 配装 使用 Hexo</strong></p>
<p>Hexo需要的环境搭建好之后，我们开始安装hexo 。 </p>
<p><em>安装Hexo</em> </p>
<p>在电脑的任意位置，创建一个文件夹，文字随便命名看你喜欢了，鼠标右键，点击Git Bash Here ,输入命令即可安装 。</p>
<ol>
<li>npm install -g hexo </li>
<li>npm install hexo –save </li>
<li>hexo init </li>
<li>npm install </li>
<li>npm install hexo-deployer-git –save  //ERROR Deployer not found: git 安装这个插件</li>
</ol>
<p>安装成功的目录：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2192701-ab6dce55e8cdcf81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>本地查看运行效果：</strong></p>
<p>运行命令：</p>
<p>hexo generate 命令简写 hexo g<br>hexo server   命令简写 hexo s </p>
<p>浏览器运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2192701-9cd962701c4fcb58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在浏览器输入 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> , 即可看到本地的运行的效果。</p>
<p><strong>淘宝源安装</strong></p>
<ul>
<li>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a><br>之后的安装就是把npm install 换成 cnpm install  </li>
</ul>
<p>看到上面的图片，说明我们hexo本地的安装已经成功，接下来就是将我们的文件上传到github了，首先我们需要有一个github账号，直接去注册就好了，作为一个屌丝程序员，怎么可能没有github账号，之后就是设置ssh公钥，设置的方式：</p>
<ul>
<li>登陆账号后，鼠标点击你的头像，点击-Your profile </li>
<li>点击左边的 ， Edit profile </li>
<li>左边，SSH and GPG keys </li>
<li>右边，New SSH key </li>
<li>随便输入 title , key 文本框中，输入公钥，点击Add SSH key </li>
</ul>
<p><strong>创建仓库</strong></p>
<ul>
<li>New repository ， 创建新仓库</li>
<li>Repository name ,这个是重点 ！！一点要填写为：你的账号名.github.io 。 </li>
<li>完成仓库的创建 。 </li>
</ul>
<p>结果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2192701-cb79fd9e940629f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>部署到github</strong></p>
<p>仓库创建成功以后，我们可以将本地的网页文件上传到github了，下面我们看一下具体的设置：</p>
<p>打开,你创建文件夹的根目录 ，找到 _config.yml文件 ，在最后面添加下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: 你的仓库地址</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>hexo 的配置已经完成。</p>
<p>接下来，我们使用hexo命令将文件上传到github仓库中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean # 清楚缓存</div><div class="line">hexo g  # 生成静态网页至public目录</div><div class="line">hexo d  # 发布到github</div></pre></td></tr></table></figure>
<p>效果如下图说明发布成功</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2192701-7d68f7fee415bf96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在浏览器输入 Your-Github-Name.github.io ,就可以查看你的博客了。</p>
<p>到这里，博客已经基本创建好了，后续会继续跟进博客主题的替换，博客样式的设置。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很久之前就像要一个自己的博客，想在这个浩瀚的网络上，能有一个自己的小家，简单的写写文章，记录一下自己的心路历程。虽然有各种博客，但是风格都是官方定好的，完全没有自己发挥的空间。 虽然wordpress可以搭建个人博客，但是服务器空间域名等都需要钱来维护，而且wordpress使用起来也不是很爽。直到发现了githubpage和hexo。一颗躁动的心又要起航了。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="http://www.github.com/topyuluo/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://www.github.com/topyuluo/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.github.com/topyuluo/2016/12/12/hello-world/"/>
    <id>http://www.github.com/topyuluo/2016/12/12/hello-world/</id>
    <published>2016-12-11T16:22:58.281Z</published>
    <updated>2016-12-13T12:24:58.397Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
